angular.module('underscore', []).factory('_', [
  '$window',
  function ($window) {
    return $window._
  }
]),
  angular.module('snackbar', []).factory('Snackbar', [
    '$window',
    function ($window) {
      return $window.Snackbar
    }
  ]),
  angular
    .module('trudesk', [
      'ionic',
      'ngCordova',
      'ngStorage',
      'underscore',
      'trudesk.controllers',
      'trudesk.services',
      'fileOnChange',
      'angular-peity',
      'snackbar',
      'ngCropper',
      'monospaced.elastic',
      'angularMoment',
      'jett.ionic.filter.bar',
      'angular.img'
    ])
    .run(function ($ionicPlatform, $rootScope, $location, $localStorage, $state, $http) {
      $localStorage.accessToken
        ? ($http.defaults.headers.common.accesstoken = $localStorage.accessToken)
        : ($http.defaults.headers.common.accesstoken = ''),
        $ionicPlatform.ready(function () {
          window.cordova &&
            window.cordova.plugins &&
            window.cordova.plugins.Keyboard &&
            (cordova.plugins.Keyboard.hideKeyboardAccessoryBar(!0), cordova.plugins.Keyboard.disableScroll(!0)),
            ionic.Platform.isIPad()
              ? window.screen && window.screen.orientation.unlock()
              : window.screen && window.screen.orientation.lock('portrait'),
            window.StatusBar && window.StatusBar.styleLightContent()
          window.plugins &&
            window.plugins.OneSignal &&
            window.plugins.OneSignal.startInit('f8e19190-b53b-4b72-bac8-210e7f31bebb')
              .handleNotificationOpened(function (jsonData) {
                if (jsonData.notification.payload && jsonData.notification.payload.additionalData) {
                  var ticketUid = jsonData.notification.payload.additionalData.ticketUid
                  ticketUid &&
                    ($state.go('tab.tickets'),
                    setTimeout(function () {
                      return $state.go('tab.tickets-details', { ticketuid: ticketUid })
                    }, 850))
                }
              })
              .endInit(),
            $rootScope.$on('$stateChangeStart', function (event, next, current) {
              if ('/login' !== $location.url() && (null == $localStorage.accessToken || null == $localStorage.server))
                return $location.path('/login')
            }),
            setTimeout(function () {
              angular.element(document.querySelector('#loader')).addClass('hide')
            }, 900)
        })
    })
    .filter('htmlToPlaintext', function () {
      return function (text) {
        return (text = (text = (text = (text = text ? String(text).replace(/<[^>]+>/gm, '') : '')
          ? String(text).replace(/&amp;/gm, '&')
          : '')
          ? String(text).replace(/&quot;/gm, '"')
          : '')
          ? String(text).replace(/&#39;/gm, "'")
          : '')
      }
    })
    .filter('removeHTMLTags', function () {
      return function (text) {
        return text ? String(text).replace(/<[^>]+>/gm, ' ') : ''
      }
    })
    .filter('nl2br', [
      '$filter',
      function ($filter) {
        return function (data) {
          return data ? data.replace(/\n\r?/g, '<br>') : data
        }
      }
    ])
    .filter('sanitize', [
      '$sce',
      function ($sce) {
        return function (htmlCode) {
          return $sce.trustAsHtml(htmlCode)
        }
      }
    ])
    .filter('currentdate', [
      '$filter',
      function ($filter) {
        return function () {
          return $filter('date')(new Date(), 'M/dd/yy h:mm a')
        }
      }
    ])
    .filter('statusMap', function () {
      return function (s) {
        var status
        switch (s) {
          case 0:
            status = 'New'
            break
          case 1:
            status = 'Open'
            break
          case 2:
            status = 'Pending'
            break
          case 3:
            status = 'Closed'
        }
        return status
      }
    })
    .filter('assigneeMap', function () {
      return function (a) {
        return null == a ? 'No Assignee' : a
      }
    })
    .filter('conversationFrom', function () {
      return function (p, loggedInUser) {
        for (var final, i = 0; i < p.length; i++) p[i].username != loggedInUser.username && (final = p[i])
        return final
      }
    })
    .config(function ($stateProvider, $urlRouterProvider) {
      ionic.Platform.setPlatform('ios'),
        $stateProvider
          .state('login', { url: '/login', templateUrl: 'templates/login.html', controller: 'LoginCtrl' })
          .state('tab', { url: '/tab', abstract: !0, templateUrl: 'templates/tabs.html' })
          .state('tab.dash', {
            url: '/dash',
            views: { 'tab-dash': { templateUrl: 'templates/tab-dash.html', controller: 'DashCtrl' } }
          })
          .state('tab.tickets', {
            url: '/tickets',
            views: { 'tab-tickets': { templateUrl: 'templates/tab-tickets.html', controller: 'TicketsCtrl' } }
          })
          .state('tab.tickets-details', {
            url: '/tickets/:ticketuid',
            views: { 'tab-tickets': { templateUrl: 'templates/ticket-detail.html', controller: 'TicketsDetailCtrl' } }
          })
          .state('tab.messages', {
            url: '/messages',
            views: { 'tab-messages': { templateUrl: 'templates/tab-messages.html', controller: 'MessagesCtrl' } }
          })
          .state('tab.messages-conversation', {
            url: '/messages/:conversationid',
            views: {
              'tab-messages': {
                templateUrl: 'templates/conversation.html',
                controller: 'ConversationCtrl',
                controllerAs: 'ConversationCtrl'
              }
            }
          })
          .state('tab.account', {
            url: '/account',
            views: { 'tab-account': { templateUrl: 'templates/tab-account.html', controller: 'AccountCtrl' } }
          }),
        $urlRouterProvider.otherwise('/login')
    })
var angularPeity = angular.module('angular-peity', []),
  peityDirective = function (type) {
    return {
      restrict: 'E',
      require: 'ngModel',
      scope: { options: '=' },
      link: function (scope, element, attrs, ngModel) {
        var options = {}
        scope.options && (options = scope.options),
          (element[0].innerText = ngModel.$viewValue),
          (attrs.val = ngModel.$viewValue),
          (ngModel.$render = function () {
            ;(element[0].innerText = ngModel.$viewValue), jQuery(element[0]).peity(type, options)
          })
      }
    }
  }
angularPeity.directive('pieChart', function () {
  return peityDirective('donut')
}),
  angularPeity.directive('barChart', function () {
    return peityDirective('bar')
  }),
  angularPeity.directive('lineChart', function () {
    return peityDirective('line')
  })
var fileOnChange = angular.module('fileOnChange', [])
fileOnChange.directive('fileOnChange', function () {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      var onChangeHandler = scope.$eval(attrs.fileOnChange)
      element.bind('change', onChangeHandler)
    }
  }
})
var autoLinker = angular.module('autolinker', [])
autoLinker.directive('autolinker', [
  '$timeout',
  function ($timeout) {
    return {
      restrict: 'A',
      link: function (scope, element, attrs) {
        $timeout(function () {
          var eleHtml = element.html()
          if ('' === eleHtml) return !1
          var text = AutoLinker.link(eleHtml, { className: 'autolinker', newWindow: !1 })
          element.html(text)
          for (var autolinks = element[0].getElementsByClassName('autolinker'), i = 0; i < autolinks.length; i++)
            angular.element(
              autolinks[i].bind('click', function (e) {
                var href = e.target.href
                return href && window.open(href, '_blank'), e.preventDefault(), !1
              })
            )
        }, 0)
      }
    }
  }
])
var hideTabBar = angular.module('hideTabBar', [])
function ensureLogin ($localStorage, $state) {
  if (void 0 === $localStorage.server || void 0 === $localStorage.accessToken) return $state.go('login')
}
function ensureLogin ($localStorage, $state) {
  if (void 0 === $localStorage.server || void 0 === $localStorage.accessToken) return $state.go('login')
}
function ensureLogin ($localStorage, $state) {
  if (void 0 === $localStorage.server || void 0 === $localStorage.accessToken) return $state.go('login')
}
function ensureLogin ($localStorage, $state) {
  if (void 0 === $localStorage.server || void 0 === $localStorage.accessToken) return $state.go('login')
}
hideTabBar.directive('hideTabBar', function ($timeout) {
  var style = angular
    .element('<style>')
    .html('.has-tabs.no-tabs:not(.has-tabs-top) { bottom: 0; }\n.no-tabs.has-tabs-top { top: 44px; }')
  return (
    document.body.appendChild(style[0]),
    {
      restrict: 'A',
      compile: function (element, attr) {
        var tabBar = document.querySelector('.tab-nav')
        return function ($scope, $element, $attr) {
          var scroll = $element[0].querySelector('.scroll-content')
          $scope.$on('$ionicView.beforeEnter', function () {
            tabBar.classList.add('slide-away'), scroll.classList.add('no-tabs')
          }),
            $scope.$on('$ionicView.beforeLeave', function () {
              tabBar.classList.remove('slide-away'), scroll.classList.remove('no-tabs')
            })
        }
      }
    }
  )
}),
  angular.module('ionic').directive('ionInfiniteScrollReverse', [
    '$timeout',
    function ($timeout) {
      return {
        restrict: 'E',
        require: ['?^$ionicScroll', 'ionInfiniteScrollReverse'],
        template: function ($element, $attrs) {
          return $attrs.icon
            ? '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>'
            : '<ion-spinner icon="{{spinner()}}"></ion-spinner>'
        },
        scope: !0,
        controller: '$ionInfiniteScrollReverse',
        link: function ($scope, $element, $attrs, ctrls) {
          var infiniteScrollCtrl = ctrls[1],
            scrollCtrl = (infiniteScrollCtrl.scrollCtrl = ctrls[0])
          if ((infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative()))
            (infiniteScrollCtrl.scrollView = scrollCtrl.scrollView),
              ($scope.scrollingType = 'js-scrolling'),
              scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds)
          else {
            var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll')
            if (!(infiniteScrollCtrl.scrollEl = scrollEl)) throw 'Infinite scroll must be used inside a scrollable div'
            infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds)
          }
          ;(!angular.isDefined($attrs.immediateCheck) || $scope.$eval($attrs.immediateCheck)) &&
            $timeout(function () {
              infiniteScrollCtrl.checkBounds()
            })
        }
      }
    }
  ]),
  angular.module('ionic').controller('$ionInfiniteScrollReverse', [
    '$scope',
    '$attrs',
    '$element',
    '$timeout',
    function ($scope, $attrs, $element, $timeout) {
      var self = this
      function onInfinite () {
        ionic.requestAnimationFrame(function () {
          $element[0].classList.add('active')
        }),
          (self.isLoading = !0),
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '')
      }
      function finishInfiniteScroll () {
        ionic.requestAnimationFrame(function () {
          $element[0].classList.remove('active')
        }),
          $timeout(
            function () {
              self.jsScrolling && self.scrollView.resize(),
                ((self.jsScrolling && self.scrollView.__container && 0 < self.scrollView.__container.offsetHeight) ||
                  !self.jsScrolling) &&
                  self.checkBounds()
            },
            30,
            !1
          ),
          (self.isLoading = !1)
      }
      function calculateMaxValue (maximum) {
        var distance = ($attrs.distance || '2.5%').trim(),
          isPercent = -1 !== distance.indexOf('%')
        return $attrs.reverse
          ? isPercent
            ? maximum - maximum * (1 - parseFloat(distance) / 100)
            : parseFloat(distance)
          : isPercent
          ? maximum * (1 - parseFloat(distance) / 100)
          : maximum - parseFloat(distance)
      }
      ;(self.isLoading = !1),
        ($scope.icon = function () {
          return angular.isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d'
        }),
        ($scope.spinner = function () {
          return angular.isDefined($attrs.spinner) ? $attrs.spinner : ''
        }),
        $scope.$on('scroll.infiniteScrollComplete', function () {
          finishInfiniteScroll()
        }),
        $scope.$on('$destroy', function () {
          self.scrollCtrl && self.scrollCtrl.$element && self.scrollCtrl.$element.off('scroll', self.checkBounds),
            self.scrollEl &&
              self.scrollEl.removeEventListener &&
              self.scrollEl.removeEventListener('scroll', self.checkBounds)
        }),
        (self.checkBounds = ionic.Utils.throttle(function () {
          if (self.isLoading) return
          var maxScroll = {}
          if (self.jsScrolling) {
            maxScroll = self.getJSMaxScroll()
            var scrollValues = self.scrollView.getValues()
            $attrs.reverse
              ? ((-1 !== maxScroll.left && scrollValues.left <= maxScroll.left) ||
                  (-1 !== maxScroll.top && scrollValues.top <= maxScroll.top)) &&
                onInfinite()
              : ((-1 !== maxScroll.left && scrollValues.left >= maxScroll.left) ||
                  (-1 !== maxScroll.top && scrollValues.top >= maxScroll.top)) &&
                onInfinite()
          } else (maxScroll = self.getNativeMaxScroll()), $attrs.reverse ? ((-1 !== maxScroll.left && self.scrollEl.scrollLeft <= maxScroll.left) || (-1 !== maxScroll.top && self.scrollEl.scrollTop <= maxScroll.top)) && onInfinite() : ((-1 !== maxScroll.left && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (-1 !== maxScroll.top && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) && onInfinite()
        }, 300)),
        (self.getJSMaxScroll = function () {
          var maxValues = self.scrollView.getScrollMax()
          return {
            left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
            top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
          }
        }),
        (self.getNativeMaxScroll = function () {
          var maxValues = { left: self.scrollEl.scrollWidth, top: self.scrollEl.scrollHeight },
            computedStyle = window.getComputedStyle(self.scrollEl) || {}
          return {
            left:
              !maxValues.left ||
              ('scroll' !== computedStyle.overflowX &&
                'auto' !== computedStyle.overflowX &&
                'scroll' !== self.scrollEl.style['overflow-x'])
                ? -1
                : calculateMaxValue(maxValues.left),
            top:
              !maxValues.top ||
              ('scroll' !== computedStyle.overflowY &&
                'auto' !== computedStyle.overflowY &&
                'scroll' !== self.scrollEl.style['overflow-y'])
                ? -1
                : calculateMaxValue(maxValues.top)
          }
        }),
        (self.__finishInfiniteScroll = finishInfiniteScroll)
    }
  ]),
  angular
    .module('trudesk.services', [])
    .factory('WebSocket', function ($q, $rootScope, $timeout, $http, $localStorage) {
      var dataStream = io.connect('/', { query: 'token=' + $localStorage.accessToken })
      return (
        dataStream.on('connect', function () {
          console.log('Connected to Server: ' + $localStorage.server)
        }),
        dataStream.on('disconnect', function () {
          console.log('Disconnected from Server: ' + $localStorage.server)
        }),
        dataStream.on('error', function (e) {
          console.log('Error', e)
        }),
        dataStream.on('joinSuccessfully', function () {
          console.log('Joined Messaging Server.')
        }),
        dataStream.removeAllListeners('chatMessage'),
        dataStream.on('chatMessage', function (data) {
          window.dispatchEvent(new CustomEvent('$trudesk.converstation.chatmessage', { detail: data }))
        }),
        dataStream.on('updateUsers', function (users) {
          window.dispatchEvent(new CustomEvent('$trudesk.conversation.updateusers', { detail: users }))
        }),
        dataStream.on('chatTyping', function (data) {
          ionic.trigger('$trudesk.conversation.usertyping', data)
        }),
        dataStream.on('chatStopTyping', function (data) {
          ionic.trigger('$trudesk.conversation.userstoptyping', data)
        }),
        {
          message: void 0,
          socket: dataStream,
          startTyping: function (convoId, partnerId, loggedInUserId) {
            dataStream.emit('chatTyping', { cid: convoId, to: partnerId, from: loggedInUserId })
          },
          stopTyping: function (convoId, partnerId) {
            dataStream.emit('chatStopTyping', { cid: convoId, to: partnerId })
          },
          send: function (convoId, partnerId, loggedInUserId, messageId, messageBody) {
            dataStream.emit('chatMessage', {
              conversation: convoId,
              to: partnerId,
              from: loggedInUserId,
              type: 's',
              messageId: messageId,
              message: messageBody
            })
          },
          updateUsers: function () {
            return dataStream.emit('updateUsers')
          },
          checkConnection: function () {
            ;(null != dataStream && dataStream.connected) ||
              (console.log('Reconnecting to: ' + $localStorage.server),
              (dataStream = void 0),
              (dataStream = io.connect('http://' + $localStorage.server, {
                query: 'token=' + $localStorage.accessToken
              })))
          },
          close: function () {
            return console.log('Closing Socket...'), dataStream.disconnect()
          }
        }
      )
    })
    .factory('Roles', function ($q, $http, $localStorage) {
      return {
        flushRoles: function () {
          return new Promise(function (resolve, reject) {
            $http
              .get('http://' + $localStorage.server + '/api/v1/roles', {
                headers: { accesstoken: $localStorage.accessToken }
              })
              .then(function (res) {
                if (res.data) {
                  var obj = { roles: $localStorage.roles.roles, roleOrder: $localStorage.roles.roleOrder }
                  return (
                    res.data.roles && (obj.roles = res.data.roles),
                    res.data.roleOrder && (obj.roleOrder = res.data.roleOrder),
                    ($localStorage.roles = obj),
                    resolve(obj)
                  )
                }
              })
              .catch(function (err) {
                return reject(err)
              })
          })
        },
        canUser: function (a) {
          var roles = $localStorage.roles.roles,
            rolePerm = _.find(roles, function (r) {
              return r._id.toString() === $localStorage.loggedInUser.role._id.toString()
            })
          if (_.isUndefined(rolePerm)) return !1
          rolePerm._id
          if (-1 !== _.indexOf(rolePerm.grants, '*')) return !0
          var actionType = a.split(':')[0],
            action = a.split(':')[1]
          if (_.isUndefined(actionType) || _.isUndefined(action)) return !1
          var result = _.filter(rolePerm.grants, function (value) {
            if (0 === value.lastIndexOf(actionType + ':')) return value
          })
          if (_.isUndefined(result) || _.size(result) < 1) return !1
          if (1 === _.size(result) && '*' === result[0]) return !0
          var typePerm = result[0].split(':')[1].split(' ')
          return (typePerm = _.uniq(typePerm)), -1 !== _.indexOf(typePerm, '*') || -1 !== _.indexOf(typePerm, action)
        }
      }
    })
    .factory('Users', function ($q, $http, $localStorage) {
      return {
        getImage: function (url) {
          return new Promise(function (resolve, reject) {
            $http
              .get(url, { method: 'GET', headers: { accesstoken: $localStorage.accessToken } })
              .then(function (response) {
                var objectUrl = URL.createObjectURL(response.blob())
                return resolve(objectUrl)
              })
              .catch(function (err) {
                return reject(err)
              })
          })
        },
        get: function (username) {
          return $http.get('/api/v1/users/' + username, { headers: { accesstoken: $localStorage.accessToken } })
        },
        getUsers: function () {
          return $http.get('/api/v1/users?limit=-1', { headers: { accesstoken: $localStorage.accessToken } })
        },
        getAssignees: function () {
          return $http.get('/api/v1/users/getassignees', { headers: { accesstoken: $localStorage.accessToken } })
        },
        getRoles: function () {
          return $http.get('/api/v1/roles', { headers: { accesstoken: $localStroage.accessToken } })
        },
        getLoggedInUser: function () {
          var deferred = $q.defer()
          return (
            $localStorage.loggedInUser
              ? deferred.resolve($localStorage.loggedInUser)
              : $localStorage.username
              ? $http
                  .get('/api/v1/users/' + $localStorage.username, {
                    headers: { accesstoken: $localStorage.accessToken }
                  })
                  .then(
                    function (response) {
                      response.data.user
                        ? (($localStorage.loggedInUser = response.data.user),
                          void 0 === $localStorage.loggedInUser.image &&
                            ($localStorage.loggedInUser.image = 'defaultProfile.jpg'),
                          deferred.resolve($localStorage.loggedInUser))
                        : deferred.reject('Unable to get user')
                    },
                    function (response) {
                      console.log(response), deferred.reject('Error Occured!')
                    }
                  )
              : deferred.reject('No username stored.'),
            deferred.promise
          )
        },
        isUserOnline: function (onlineUsers, userObj) {
          return void 0 !== userObj && (void 0 !== onlineUsers && void 0 !== onlineUsers[userObj.username])
        }
      }
    })
    .factory('Tickets', function ($http, $localStorage) {
      return {
        all: function (page) {
          void 0 === page && (page = 0)
          var queryString = '/api/v1/tickets?limit=10&status[]=0&status[]=1&status[]=2&page=' + page
          return (
            void 0 !== $localStorage.showClosedTickets &&
              !0 === $localStorage.showClosedTickets &&
              (queryString += '&status[]=3'),
            void 0 !== $localStorage.showOnlyAssigned &&
              !0 === $localStorage.showOnlyAssigned &&
              (queryString += '&assignedself=true'),
            $http.get(queryString, { headers: { accesstoken: $localStorage.accessToken } })
          )
        },
        get: function (uid) {
          return $http.get('/api/v1/tickets/' + uid, { headers: { accesstoken: $localStorage.accessToken } })
        },
        create: function (ticket) {
          return $http.post('/api/v1/tickets/create', ticket, { headers: { accesstoken: $localStorage.accessToken } })
        },
        search: function (search) {
          return $http.get('/api/v1/tickets/search/?search=' + search, {
            headers: { accesstoken: $localStorage.accessToken }
          })
        },
        update: function (ticket) {
          return $http.put('/api/v1/tickets/' + ticket._id, ticket, {
            headers: { accesstoken: $localStorage.accessToken }
          })
        },
        addComment: function (ticket, comment) {
          return $http.post(
            '/api/v1/tickets/addcomment',
            { _id: ticket._id, comment: comment.comment, ownerId: comment.ownerId },
            { headers: { accesstoken: $localStorage.accessToken } }
          )
        },
        addNote: function (ticket, note) {
          return $http.post(
            '/api/v1/tickets/addnote',
            { ticketid: ticket._id, note: note.note, owner: note.ownerId },
            { headers: { accesstoken: $localStorage.accessToken } }
          )
        },
        ticketStats: function (timespan) {
          return $http.get('/api/v1/tickets/stats/' + timespan, { headers: { accesstoken: $localStorage.accessToken } })
        }
      }
    })
    .factory('Groups', function ($http, $localStorage) {
      return {
        all: function () {
          return $http.get('/api/v1/groups', { headers: { accesstoken: $localStorage.accessToken } })
        },
        get: function (_id) {
          return $http.get('/api/v1/groups/' + _id, { headers: { accesstoken: $localStorage.accessToken } })
        }
      }
    })
    .factory('TicketTypes', function ($http, $localStorage) {
      return {
        all: function () {
          return $http.get('/api/v1/tickets/types', { headers: { accesstoken: $localStorage.accessToken } })
        },
        get: function (typeId) {
          return $http.get('http://' + $localStorage.server + '/api/v1/tickets/type/' + typeId, {
            headers: { accesstoken: $localStorage.accessToken }
          })
        }
      }
    })
    .factory('Priorities', function ($http, $localStorage) {
      return {
        all: function () {
          return $http.get('http://' + $localStorage.server + '/api/v1/tickets/priorities', {
            headers: { accesstoken: $localStorage.accessToken }
          })
        }
      }
    })
    .factory('Messages', function ($http, $localStorage) {
      return {
        getConversation: function (convoId, page) {
          void 0 === page && (page = 0)
          var queryString = '/api/v1/messages/conversation/' + convoId + '?page=' + page
          return $http.get(queryString, { headers: { accesstoken: $localStorage.accessToken } })
        },
        getRecent: function () {
          return $http.get('/api/v1/messages/conversations/recent', {
            headers: { accesstoken: $localStorage.accessToken }
          })
        },
        sendMessage: function (convoId, message) {
          return $http.post(
            '/api/v1/messages/send',
            { cId: convoId, owner: message.ownerId, body: message.body },
            { headers: { accesstoken: $localStorage.accessToken } }
          )
        },
        startConversation: function (userId) {
          return $http.post(
            '/api/v1/messages/conversation/start',
            { owner: $localStorage.loggedInUser._id, participants: [$localStorage.loggedInUser._id, userId] },
            { headers: { accesstoken: $localStorage.accessToken } }
          )
        },
        deleteConversation: function (convoId) {
          return $http.delete('/api/v1/messages/conversation/' + convoId, {
            headers: { accesstoken: $localStorage.accessToken }
          })
        }
      }
    })
    .factory('Graphs', function ($http, $localStorage) {
      return {
        topGroups: function () {
          return $http.get('/api/v1/tickets/count/topgroups', { headers: { accesstoken: $localStorage.accessToken } })
        }
      }
    })
    .factory('Camera', function ($q, $cordovaCamera, $ionicPlatform) {
      return {
        open: function () {
          var deferred = $q.defer()
          if (ionic.Platform.isWebView()) {
            var options = {
              quality: 80,
              destinationType: Camera.DestinationType.FILE_URI,
              sourceType: Camera.PictureSourceType.CAMERA,
              encodingType: Camera.EncodingType.JPEG
            }
            $cordovaCamera.getPicture(options).then(function (fileURL) {
              deferred.resolve(fileURL)
            })
          } else deferred.reject('Not Supported in browser')
          return deferred.promise
        },
        library: function () {
          var deferred = $q.defer()
          if (ionic.Platform.isWebView()) {
            var options = {
              quality: 80,
              destinationType: Camera.DestinationType.FILE_URI,
              sourceType: Camera.PictureSourceType.PHOTOLIBRARY,
              encodingType: Camera.EncodingType.JPEG
            }
            $cordovaCamera.getPicture(options).then(function (fileURL) {
              return $ionicPlatform.is('ios')
                ? deferred.resolve(fileURL)
                : $ionicPlatform.is('android')
                ? void window.FilePath.resolveNativePath(fileURL, function (resolvedFileURI) {
                    return deferred.resolve(resolvedFileURI)
                  })
                : deferred.reject('Unsupported Platform')
            })
          } else deferred.reject('Not Supported in browser')
          return deferred.promise
        }
      }
    })
    .factory('Upload', function ($q, $cordovaCamera, $cordovaFileTransfer, $localStorage) {
      return {
        profilePicture: function (fileURL) {
          var deferred = $q.defer()
          if (ionic.Platform.isWebView()) {
            var serverURL = '/api/v1/users/' + $localStorage.username + '/uploadprofilepic',
              uploadOptions = new FileUploadOptions()
            ;(uploadOptions.fileKey = 'file'),
              (uploadOptions.fileName = fileURL.substr(fileURL.lastIndexOf('/') + 1)),
              (uploadOptions.mimeType = 'image/jpeg'),
              new FileTransfer().upload(
                fileURL,
                encodeURI(serverURL),
                function (result) {
                  var response = result.response,
                    responseObj = JSON.parse(response)
                  deferred.resolve(responseObj)
                },
                function (err) {
                  deferred.reject(err)
                },
                uploadOptions
              )
          } else deferred.reject('Not Supported')
          return deferred.promise
        }
      }
    }),
  angular.module('trudesk.controllers', [
    'trudesk.controllers.login',
    'trudesk.controllers.dashboard',
    'trudesk.controllers.tickets',
    'trudesk.controllers.ticketDetails',
    'trudesk.controllers.accounts',
    'trudesk.controllers.messages',
    'trudesk.controllers.messages.conversation',
    'trudesk.controllers.imgCrop',
    'trudesk.controllers.graphs'
  ]),
  angular
    .module('trudesk.controllers.login', [])
    .controller('LoginCtrl', function ($http, $scope, $state, $localStorage, $ionicLoading, $ionicPopup) {
      function showError (err) {
        $ionicPopup.alert({ title: 'Error', template: err, okType: 'button-assertive' }).then(function () {})
      }
      $ionicLoading.show({ templateUrl: 'templates/modals/modal-loading.html', noBackdrop: !0, duration: 1200 }),
        ($scope.auth = { server: '', username: '', password: '' }),
        ($scope.invalid = { server: !1, username: !1, password: !1 }),
        ($scope.login = function (loginForm) {
          loginForm.$valid
            ? (($scope.invalid.server = !1),
              ($scope.invalid.username = !1),
              ($scope.invalid.password = !1),
              $ionicLoading.show({ templateUrl: 'templates/modals/modal-loading.html', noBackdrop: !0 }),
              ($scope.auth.server = $scope.auth.server.replace(/^https?:\/\//, '')),
              $http
                .post('/api/v1/login', { username: $scope.auth.username, password: $scope.auth.password })
                .then(
                  function (response) {
                    !1 === response.data.success
                      ? showError(response.data.error)
                      : void 0 !== response.data.accessToken &&
                        (($localStorage.server = ''),
                        ($localStorage.username = $scope.auth.username),
                        ($localStorage.accessToken = response.data.accessToken),
                        ($localStorage.loggedInUser = response.data.user),
                        ($http.defaults.headers.common.accesstoken = $localStorage.accessToken),
                        window.plugins &&
                          window.plugins.OneSignal &&
                          (window.plugins.OneSignal.setSubscription(!0),
                          window.plugins.OneSignal.sendTags({
                            host: $localStorage.server,
                            user: $localStorage.loggedInUser._id
                          })),
                        $http
                          .get('/api/v1/roles', { headers: { accesstoken: $localStorage.accessToken } })
                          .then(
                            function (response) {
                              $localStorage.roles = response.data
                            },
                            function (response) {
                              console.log('Error', response)
                            }
                          )
                          .then(function () {
                            $state.go('tab.dash')
                          }))
                  },
                  function (response) {
                    switch ((console.error(response), response.status)) {
                      case -1:
                        showError('Could not connect. Please check server and try again.')
                        break
                      case 401:
                        showError('Invalid Username / Password')
                        break
                      default:
                        showError('Could not connect. Please check server and try again.')
                    }
                  }
                )
                .then(function () {
                  setTimeout(function () {
                    $ionicLoading.hide()
                  }, 500)
                }))
            : (($scope.invalid.server = loginForm.server.$invalid),
              ($scope.invalid.username = loginForm.username.$invalid),
              ($scope.invalid.password = loginForm.password.$invalid))
        }),
        ionic.on('$trudesk.clearLoginForm', function () {
          ;($scope.auth.server = ''), ($scope.auth.username = ''), ($scope.auth.password = '')
        }),
        $scope.$on('$ionicView.enter', function () {
          setTimeout(function () {
            if (void 0 !== $localStorage.server && void 0 !== $localStorage.accessToken) return $state.go('tab.dash')
            window.StatusBar && window.StatusBar.styleDefault(),
              angular
                .element(document)
                .find('ion-view')
                .removeClass('hide'),
              window.plugins && window.plugins.OneSignal && window.plugins.OneSignal.setSubscription(!1)
          }, 600)
        })
    }),
  angular
    .module('trudesk.controllers.accounts', [])
    .controller('AccountCtrl', function (
      $q,
      $scope,
      $state,
      $http,
      $timeout,
      $localStorage,
      $ionicHistory,
      $ionicActionSheet,
      $ionicModal,
      $cordovaCamera,
      Camera,
      Users,
      Upload
    ) {
      ;($scope.server = $localStorage.server),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-imgcrop.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.imgcropModal = modal
          }),
        ionic.on('$trudesk.showCropper', function () {
          $scope.imgcropModal.show()
        }),
        ionic.on('$trudesk.hideCropper', function () {
          $scope.imgcropModal.hide()
        }),
        ($scope.showActionSheet = function (event) {
          if (ionic.Platform.isWebView())
            $ionicActionSheet.show({
              buttons: [{ text: 'Take Photo' }, { text: 'Open Photo Library' }],
              titleText: 'Account Picture',
              cancelText: 'Cancel',
              cancel: function () {},
              buttonClicked: function (index) {
                switch (index) {
                  case 0:
                    return $scope.openCamera(), !0
                  case 1:
                    return $scope.openPhotoLibrary(), !0
                  default:
                    return !0
                }
              }
            })
        }),
        ($scope.openCamera = function () {
          Camera.open().then(function (fileURL) {
            ionic.trigger('$trudesk.imgcrop.setImage', { image: window.Ionic.WebView.convertFileSrc(fileURL) }),
              ionic.trigger('$trudesk.imgcrop.showCropper', {}),
              $scope.imgcropModal.show()
          })
        }),
        ($scope.openPhotoLibrary = function () {
          Camera.library().then(function (fileURL) {
            ionic.trigger('$trudesk.imgcrop.setImage', { image: window.Ionic.WebView.convertFileSrc(fileURL) }),
              ionic.trigger('$trudesk.imgcrop.showCropper', {}),
              $scope.imgcropModal.show()
          }),
            ionic.on('$trudesk.account.updateImage', function (data) {
              $scope.updateAccountImage()
            })
        }),
        ($scope.logout = function ($event) {
          $event.preventDefault(),
            $http
              .get('/logout/', { timeout: 2e3 })
              .then(function (response) {}, function (response) {})
              .finally(function () {
                return (
                  ionic.trigger('$trudesk.clearLoginForm', {}),
                  ($localStorage.server = void 0),
                  ($localStorage.accessToken = void 0),
                  ($http.defaults.headers.common.accesstoken = $localStorage.accessToken),
                  window.plugins && window.plugins.OneSignal && window.plugins.OneSignal.setSubscription(!1),
                  $ionicHistory.clearCache(),
                  $state.go('login')
                )
              })
        }),
        ($scope.updateAccountImage = function () {
          ;($localStorage.loggedInUser = null),
            Users.getLoggedInUser().then(
              function (user) {
                ;($scope.loggedInUser = user).image
                  ? ($scope.accountProfile =
                      '/uploads/users/' + $scope.loggedInUser.image + '?time=' + new Date().getTime())
                  : ($scope.accountProfile = '/uploads/users/defaultProfile.jpg')
              },
              function (err) {
                console.log(err)
              }
            )
        }),
        $scope.$on('$ionicView.beforeEnter', function () {
          $scope.accountProfile || ($scope.accountProfile = '/uploads/users/defaultProfile.jpg'),
            $scope.updateAccountImage()
        })
    }),
  angular
    .module('trudesk.controllers.dashboard', [])
    .controller('DashCtrl', function ($http, $scope, $state, $location, $ionicNavBarDelegate, $localStorage, Tickets) {
      function getStats (timespan) {
        Tickets.ticketStats(timespan).then(function (response) {
          $scope.totalTickets = response.data.ticketCount ? response.data.ticketCount : 0
          var closedCount = Number(response.data.closedCount)
          ;($scope.closedPercent = Math.round((closedCount / $scope.totalTickets) * 100)),
            ($scope.closedPercent = isNaN($scope.closedPercent) ? '--' : $scope.closedPercent),
            ($scope.closedPercentPie = $scope.closedPercent + '/100'),
            ($scope.ticketAvg = response.data.ticketAvg ? response.data.ticketAvg : 0)
        })
      }
      ;-1 === $location.path().indexOf('dashboard')
        ? $ionicNavBarDelegate.showBackButton(!1)
        : $ionicNavBarDelegate.showBackButton(!0),
        ($scope.totalTickets = 0),
        ($scope.timespans = [
          { label: '30 Days', value: 30 },
          { label: '60 Days', value: 60 },
          { label: '90 Days', value: 90 },
          { label: '180 Days', value: 180 },
          { label: '365 Days', value: 365 }
        ]),
        ($scope.selectedTimespan = 30),
        ($scope.barChart = [5, 3, 9, 6, 5, 9, 7]),
        ($scope.lineChart = [5, 3, 9, 6, 5, 9, 7, 3, 5, 2]),
        getStats(30),
        ($scope.timespanChange = function ($event) {
          ;($scope.selectedTimespan = this.selectedTimespan), getStats($scope.selectedTimespan)
        }),
        $scope.$on('$ionicView.enter', function () {
          window.StatusBar && window.StatusBar.styleLightContent()
        }),
        $scope.$on('$ionicView.beforeEnter', function () {
          ensureLogin($localStorage, $state)
        })
    }),
  angular.module('trudesk.controllers.graphs', []).controller('GraphCtrl', function ($scope, $http, _, Graphs) {
    $scope.renderGraphs = function () {
      Graphs.topGroups().then(
        function (response) {
          var arr
          _.size(response.data.items) < 1 && (response.data.items = [{ name: 'No Data', count: 1 }]),
            (arr = _.map(response.data.items, function (v, k) {
              return [v.name, v.count]
            }))
          var colors = [
            '#e74c3c',
            '#3498db',
            '#9b59b6',
            '#34495e',
            '#1abc9c',
            '#2ecc71',
            '#03A9F4',
            '#00BCD4',
            '#009688',
            '#4CAF50',
            '#FF5722',
            '#CDDC39',
            '#FFC107',
            '#00E5FF',
            '#E040FB',
            '#607D8B'
          ]
          colors = _.shuffle(colors)
          var c = _.object(
            _.map(arr, function (v, i) {
              return v[0]
            }),
            colors
          )
          c3.generate({
            bindto: '#topGroupsChart',
            size: { height: 150, width: 315 },
            data: { columns: arr, type: 'pie', colors: c },
            tooltip: { show: !1 },
            pie: {
              label: {
                format: function (v, r, id) {
                  return ''
                }
              }
            }
          })
        },
        function (err) {
          console.error(err)
        }
      )
    }
  }),
  angular
    .module('trudesk.controllers.imgCrop', [])
    .controller('imgCrop', function (
      $scope,
      $state,
      $timeout,
      $localStorage,
      $cordovaCamera,
      Cropper,
      Camera,
      Upload,
      Users
    ) {
      ;($scope.options = {
        maximize: !0,
        aspectRatio: 1,
        checkImageOrigin: !0,
        rotatable: !0,
        viewMode: 1,
        dragMode: 'move',
        checkOrientation: !0
      }),
        ($scope.cropper = {}),
        ($scope.cropperProxy = 'cropper.first'),
        Users.getLoggedInUser().then(
          function (user) {
            $scope.loggedInUser = user
          },
          function (error) {
            console.log(error)
          }
        ),
        ($scope.showEvent = 'showCropper'),
        ($scope.hideEvent = 'hideCropper'),
        ($scope.close = function () {
          ionic.trigger('$trudesk.hideCropper', {})
        }),
        ($scope.save = function () {
          if ($scope.cropper.first) {
            var image = $scope.cropper.first('getCroppedCanvas', { width: 256, height: 256 }).toDataURL()
            Upload.profilePicture(image)
              .then(
                function (response) {
                  ionic.trigger('$trudesk.account.updateImage', { image: response.user.image })
                },
                function (err) {
                  console.log(err)
                }
              )
              .finally(function () {
                $scope.close()
              })
          }
        }),
        ionic.on('$trudesk.imgcrop.showCropper', function () {
          $timeout(function () {
            $scope.$broadcast($scope.hideEvent), $scope.$broadcast($scope.showEvent)
          }, 0)
        }),
        ionic.on('$trudesk.imgcrop.setImage', function (data) {
          if (void 0 === data.detail || void 0 === data.detail.image) return console.log('Invalid data.detail.image')
          $scope.o = data.detail.image
        })
    }),
  angular
    .module('trudesk.controllers.messages', [])
    .controller('MessagesCtrl', function (
      $scope,
      $state,
      $stateParams,
      $localStorage,
      $ionicListDelegate,
      $ionicNavBarDelegate,
      $ionicModal,
      $ionicPopup,
      $ionicActionSheet,
      $ionicLoading,
      $ionicScrollDelegate,
      $ionicFilterBarConfig,
      $ionicFilterBar,
      $timeout,
      $q,
      WebSocket,
      Messages,
      Users
    ) {
      var filterBarInstance
      function onUpdateUsers (data) {
        $timeout(function () {
          ;($scope.onlineUsers = data.detail),
            delete $scope.onlineUsers[$scope.loggedInUser.username],
            $ionicScrollDelegate.$getByHandle('activeUsersScroll').resize()
        }, 0)
      }
      $ionicNavBarDelegate.showBackButton(!0),
        ($ionicFilterBarConfig.theme = 'dark'),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-messages-newconversation.html', {
            scope: $scope,
            animation: 'slide-in-up'
          })
          .then(function (modal) {
            $scope.newConversation = modal
          }),
        ($scope.server = $localStorage.server),
        ($scope.socket = WebSocket),
        ($scope.recentConversations = []),
        ($scope.isUserOnline = Users.isUserOnline),
        ($scope.onlineUsers = []),
        ($scope.userList = []),
        $scope.$on('$ionicView.beforeEnter', function () {
          ensureLogin($localStorage, $state),
            ($scope.server = $localStorage.server),
            Users.getLoggedInUser()
              .then(
                function (user) {
                  $scope.loggedInUser = user
                },
                function (err) {
                  console.log(err)
                }
              )
              .then(function () {
                ionic.on('$trudesk.conversation.updateusers', onUpdateUsers, window),
                  $timeout(function () {
                    $scope.loadRecentConversations()
                  }, 0)
              })
        }),
        $scope.$on('$ionicView.enter', function (scopes, states) {}),
        $scope.$on('$stateChangeStart', function (e) {
          ionic.off('$trudesk.conversation.updateusers', onUpdateUsers, window)
        }),
        ($scope.loadRecentConversations = function () {
          Messages.getRecent().then(
            function (response) {
              ;($scope.recentConversations = response.data.conversations),
                ($scope.showRecentConversations = 1 <= _.size($scope.recentConversations))
            },
            function (err) {
              console.log(err), ($scope.showRecentConversations = !1)
            }
          )
        }),
        ($scope.showNewConversation = function () {
          $scope.getUserList().then(function () {
            $scope.newConversation.show()
          })
        }),
        ($scope.hideNewConversation = function () {
          filterBarInstance && (filterBarInstance(), (filterBarInstance = null)), $scope.newConversation.hide()
        }),
        ($scope.startConversation = function (userId) {
          Messages.startConversation(userId).then(
            function (response) {
              var convoId = response.data.conversation._id
              if (void 0 !== convoId)
                return (
                  void 0 !== $scope.newConversation && $scope.hideNewConversation(),
                  $state.go('tab.messages-conversation', { conversationid: convoId })
                )
              $scope.showSnackbar('Invalid Conversation Id', !0)
            },
            function (error) {
              $scope.showSnackbar(error, !0), console.log(error)
            }
          )
        }),
        ($scope.deleteConversation = function (convoId) {
          Messages.deleteConversation(convoId)
            .then(
              function (response) {
                if (response.data.success) {
                  var convo = _.find($scope.recentConversations, function (obj) {
                      return obj._id.toString() === convoId.toString()
                    }),
                    idx = $scope.recentConversations.indexOf(convo)
                  ;-1 !== idx && $scope.recentConversations.splice(idx, 1)
                }
              },
              function (error) {
                $scope.showSnackbar(error, !0), console.log(error)
              }
            )
            .finally(function () {
              $timeout(function () {
                $scope.loadRecentConversations()
              }, 0)
            })
        }),
        ($scope.getUserList = function () {
          return Users.getUsers().then(
            function (res) {
              for (var list = res.data.users, i = 0; i < list.length; i++)
                list[i].username === $localStorage.loggedInUser.username
                  ? list.splice(i, 1)
                  : (delete list[i].__v,
                    delete list[i].accessToken,
                    delete list[i].deleted,
                    delete list[i].groups,
                    delete list[i].lastOnline,
                    delete list[i].preferences,
                    delete list[i].role,
                    delete list[i].title)
              $scope.userList = list
            },
            function (err) {
              $scope.showSnackbar(err, !0), console.log(err)
            }
          )
        }),
        ($scope.showFilterBar = function () {
          filterBarInstance = $ionicFilterBar.show({
            items: $scope.userList,
            container: '.modal',
            debounce: !0,
            delay: 100,
            update: function (filteredItems, filterText) {
              $scope.userList = filteredItems
            }
          })
        }),
        ($scope.showSnackbar = function (text, error) {
          _.isUndefined(error) && (error = !1)
          var textColor = '#FFFFFF'
          error && (textColor = '#ef473a'),
            Snackbar.show({ text: text, showAction: !1, duration: 3e3, textColor: textColor })
        }),
        ($scope.isEmpty = function (items) {
          var bar
          for (bar in items) if (items.hasOwnProperty(bar)) return !1
          return !0
        })
    }),
  angular
    .module('trudesk.controllers.messages.conversation', [])
    .controller('ConversationCtrl', function (
      $rootScope,
      $scope,
      $state,
      $stateParams,
      $localStorage,
      $ionicListDelegate,
      $ionicNavBarDelegate,
      $ionicModal,
      $ionicPopup,
      $ionicPopover,
      $ionicActionSheet,
      $ionicLoading,
      $ionicScrollDelegate,
      $ionicHistory,
      $interval,
      $timeout,
      $q,
      moment,
      WebSocket,
      Messages,
      Users
    ) {
      $ionicNavBarDelegate.showBackButton(!0)
      var txtInput,
        viewScroll = $ionicScrollDelegate.$getByHandle('userMessageScroll')
      ;($scope.server = $localStorage.server),
        ($scope.isUserOnline = Users.isUserOnline),
        ($scope.onlineUsers = {}),
        ($scope.message = { body: '' }),
        ($scope.messages = []),
        ($scope.partnerTyping = !1),
        $ionicPopover
          .fromTemplateUrl('templates/popover/popover-messages-conversation.html', { scope: $scope })
          .then(function (popover) {
            $scope.popover = popover
          })
      var typingTimer = null,
        partnerTypingTimer = null,
        isTyping = !1
      function scrollBottom () {
        $timeout(function () {
          viewScroll.scrollBottom()
        }, 10)
      }
      function onKeyboardShow (e) {
        scrollBottom()
      }
      function onKeyboardHide (e) {
        scrollBottom()
      }
      function onPartnerTyping (data) {
        if ($scope.partnerTyping)
          return clearTimeout(partnerTypingTimer), void (partnerTypingTimer = setTimeout(cancelPartnerTyping, 15e3))
        ;($scope.partnerTyping = !0),
          scrollBottom(),
          null == partnerTypingTimer && (partnerTypingTimer = setTimeout(cancelPartnerTyping, 15e3))
      }
      function onPartnerStopTyping (data) {
        $timeout(function () {
          $scope.partnerTyping = !1
        }, 0)
      }
      function cancelPartnerTyping () {
        $timeout(function () {
          ;($scope.partnerTyping = !1), (partnerTypingTimer = void 0)
        }, 0)
      }
      function onChatMessage (data) {
        var m = {
          _id: data.detail.messageId,
          createdAt: new Date().toISOString(),
          owner: data.detail.fromUser,
          body: data.detail.message
        }
        $timeout(function () {
          $scope.messages.push(m), null != viewScroll && scrollBottom()
        }, 0)
      }
      function onUpdateUsers (data) {
        $timeout(function () {
          $scope.onlineUsers = data.detail
        }, 0)
      }
      function stopTyping () {
        ;(isTyping = !1),
          (typingTimer = void 0) !== $scope.conversation &&
            WebSocket.stopTyping($scope.conversation._id, $scope.conversation.partner._id)
      }
      $scope.$on('$ionicView.beforeEnter', function () {
        ensureLogin($localStorage, $state),
          ($scope.server = $localStorage.server),
          Users.getLoggedInUser()
            .then(
              function (user) {
                ;($scope.loggedInUser = user), $scope.getConversation()
              },
              function (err) {
                console.log(err)
              }
            )
            .then(function () {
              window.addEventListener('native.keyboardshow', onKeyboardShow),
                window.addEventListener('native.keyboardhide', onKeyboardHide),
                window.addEventListener('$trudesk.converstation.chatmessage', onChatMessage),
                window.addEventListener('$trudesk.conversation.updateusers', onUpdateUsers),
                ionic.on('$trudesk.conversation.usertyping', onPartnerTyping, window),
                ionic.on('$trudesk.conversation.userstoptyping', onPartnerStopTyping, window)
            })
            .then(function () {
              $timeout(function () {
                WebSocket.updateUsers()
              }, 0)
            })
      }),
        $scope.$on('$ionicView.enter', function () {
          txtInput = angular.element(document.body.querySelector('#message-textarea'))
        }),
        $scope.$on('$stateChangeStart', function (e) {
          window.removeEventListener('native.keyboardshow', onKeyboardShow),
            window.removeEventListener('native.keyboardhide', onKeyboardHide),
            window.removeEventListener('$trudesk.conversation.chatmessage', onChatMessage),
            ionic.off('$trudesk.conversation.usertyping', onPartnerTyping, window),
            ionic.off('$trudesk.conversation.userstoptyping', onPartnerStopTyping, window),
            window.removeEventListener('$trudesk.conversation.updateusers', onUpdateUsers),
            stopTyping(),
            (partnerTypingTimer = typingTimer = void 0)
        }),
        ($scope.getConversation = function () {
          return (
            null == $scope.page && ($scope.page = 0),
            Messages.getConversation($stateParams.conversationid, $scope.page)
              .then(
                function (response) {
                  $scope.conversation = response.data.conversation
                  for (var i = 0; i < $scope.conversation.participants.length; i++)
                    $scope.conversation.participants[i].username != $scope.loggedInUser.username &&
                      ($scope.conversation.partner = $scope.conversation.participants[i])
                  if (_.size(response.data.messages) < 1) $scope.hasMore = !1
                  else {
                    if (0 == $scope.page) $scope.messages = response.data.messages.reverse()
                    else {
                      var a = $scope.messages
                      0 < _.size(a) &&
                        ($scope.messages = _.uniq(_.union(a, response.data.messages), !1, function (i, k, a) {
                          return i._id
                        })),
                        ($scope.messages = _.sortBy($scope.messages, function (message) {
                          return message.createdAt
                        }))
                    }
                    _.size(response.data.messages) < 10 && ($scope.hasMore = !1)
                  }
                },
                function (err) {
                  console.log(err)
                }
              )
              .then(function () {
                $timeout(function () {
                  0 == $scope.page
                    ? scrollBottom()
                    : $timeout(function () {
                        viewScroll.scrollBy(0, 150, !0)
                      }),
                    $scope.page++,
                    $scope.$broadcast('scroll.infiniteScrollComplete')
                }, 0)
              })
          )
        }),
        $scope.$on('elastic:resize', function (event, element, oldHeight, newHeight) {
          $('.message-textbox')
            .css('max-height', newHeight + 'px')
            .css('height', newHeight + 'px'),
            element.css('max-height', newHeight - 1 + 'px'),
            100 <= newHeight
              ? (element.css('max-height', '99px'),
                element.css({ bottom: '5px' }),
                $('.message-textbox')
                  .css('max-height', '105px')
                  .css('height', '105px'))
              : element.css({ bottom: '0' })
        }),
        ($scope.chatTyping = function (event) {
          if (!(event.shiftKey & (13 === event.keyCode) || (13 === event.keyCode && ionic.Platform.isWebView()))) {
            if (13 === event.keyCode && !ionic.Platform.isWebView())
              return event.preventDefault(), $scope.sendChatMessage()
            if (isTyping) return clearTimeout(typingTimer), void (typingTimer = setTimeout(stopTyping, 5e3))
            ;(isTyping = !0),
              null == typingTimer && (typingTimer = setTimeout(stopTyping, 5e3)),
              WebSocket.startTyping(
                $scope.conversation._id,
                $scope.conversation.partner._id,
                $localStorage.loggedInUser._id
              )
          }
        }),
        ($scope.shouldShowDate = function (date) {
          var now = moment(),
            dMoment = moment(date)
          return 60 < now.diff(dMoment, 'minutes')
        }),
        ($scope.canFetchMoreMessages = function () {
          return void 0 === $scope.hasMore && ($scope.hasMore = !0), $scope.hasMore
        }),
        ($scope.loadMore = function () {
          if ((console.log('loading more'), i++, 10 < i && ($scope.hasMore = !1), void 0 !== $scope.conversation))
            for (var j = 0; j < 11; j++) {
              var message = {
                createdAt: new Date(),
                body: 'here',
                owner: $localStorage.loggedInUser,
                _id: Math.random()
              }
              $scope.conversation.messages.unshift(message)
            }
          $timeout(function () {
            viewScroll.scrollBy(0, 150, !0)
          }),
            $timeout(function () {
              $scope.$broadcast('scroll.infiniteScrollComplete')
            }, 3e3)
        }),
        ($scope.sendChatMessage = function () {
          if (_.isEmpty($scope.message.body)) return !1
          $scope.message.ownerId = $scope.loggedInUser._id
          var scopeMessageClone = _.clone($scope.message)
          ;($scope.message.body = ''),
            Messages.sendMessage($scope.conversation._id, scopeMessageClone).then(
              function (response) {
                var message = response.data.message
                WebSocket.send(
                  $scope.conversation._id,
                  $scope.conversation.partner._id,
                  $scope.loggedInUser._id,
                  message._id,
                  message.body
                ),
                  stopTyping(),
                  txtInput.one('blur', function () {
                    txtInput[0].focus()
                  }),
                  scrollBottom()
              },
              function (err) {
                console.log(err)
              }
            )
        })
    }),
  angular
    .module('trudesk.controllers.ticketDetails', [])
    .controller('TicketsDetailCtrl', function (
      $scope,
      $state,
      $stateParams,
      $ionicHistory,
      $ionicNavBarDelegate,
      $localStorage,
      $ionicModal,
      $ionicPopover,
      $ionicActionSheet,
      Tickets,
      Users,
      Roles
    ) {
      $ionicNavBarDelegate.showBackButton(!0),
        ($scope.showSnackbar = function (text, error) {
          _.isUndefined(error) && (error = !1)
          var textColor = '#FFFFFF'
          error && (textColor = '#ef473a'),
            Snackbar.show({ text: text, showAction: !1, duration: 3e3, textColor: textColor })
        }),
        ($scope.server = $localStorage.server),
        ($scope.loggedInUser = void 0),
        ($scope.commentModalForm = { comment: '' }),
        ($scope.noteModalForm = { note: '' }),
        ($scope.hasNotes = Roles.canUser('tickets:notes')),
        ($scope.isAgent = Roles.canUser('agent:*') || Roles.canUser('admin:*')),
        Roles.flushRoles().then(function () {
          ;($scope.hasNotes = Roles.canUser('tickets:notes')),
            ($scope.isAgent = Roles.canUser('agent:*') || Roles.canUser('admin:*'))
        }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-ticket-details.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.ticketDetailModal = modal
          }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-addComment.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.addCommentModal = modal
          }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-addNote.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.addNoteModal = modal
          }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-ticket-setAssignee.html', {
            scope: $scope,
            animation: 'slide-in-up',
            focusFirstInput: !0
          })
          .then(function (modal) {
            $scope.setAssigneeModal = modal
          }),
        Tickets.get($stateParams.ticketuid).then(function (response) {
          ;($scope.ticket = response.data.ticket),
            $scope.ticket.assignee && ($scope.selectedAssignee = $scope.ticket.assignee._id),
            void 0 === $scope.ticket.owner.image && ($scope.ticket.owner.image = 'defaultProfile.jpg'),
            ($scope.hasAssignee = 'hide'),
            void 0 !== $scope.ticket.assignee && ($scope.hasAssignee = 'show'),
            void 0 !== $scope.ticket.assignee &&
              void 0 === $scope.ticket.assignee.image &&
              ($scope.ticket.assignee.image = 'defaultProfile.jpg'),
            $scope.hasNotes
              ? ($scope.ticket.commentsMerged = _.sortBy(_.union($scope.ticket.comments, $scope.ticket.notes), 'date'))
              : ($scope.ticket.commentsMerged = $scope.ticket.comments)
        }),
        Users.getAssignees().then(
          function (response) {
            $scope.assignees = response.data.users
          },
          function (response) {
            console.log(response)
          }
        ),
        ($scope.popover = $ionicPopover
          .fromTemplateUrl('templates/popover/popover-ticket-details.html', { scope: $scope })
          .then(function (popover) {
            $scope.popover = popover
          })),
        ($scope.showStatusActionSheet = function () {
          $scope.popover.hide(),
            $ionicActionSheet.show({
              buttons: [{ text: 'Open' }, { text: 'Pending' }, { text: 'Closed' }],
              titleText: 'Set Ticket Status',
              cancelText: 'Cancel',
              cancel: function () {
                return !0
              },
              buttonClicked: function (index) {
                switch (index) {
                  case 0:
                    var reqTicket = { _id: $scope.ticket._id, status: 1 }
                    return (
                      Tickets.update(reqTicket).then(
                        function (response) {
                          ;($scope.ticket.status = 1), $scope.showSnackbar('Ticket status set to Open')
                        },
                        function (response) {
                          console.log(response)
                        }
                      ),
                      !0
                    )
                  case 1:
                    reqTicket = { _id: $scope.ticket._id, status: 2 }
                    return (
                      Tickets.update(reqTicket).then(
                        function (response) {
                          ;($scope.ticket.status = 2), $scope.showSnackbar('Ticket status set to Pending')
                        },
                        function (response) {
                          console.log(response)
                        }
                      ),
                      !0
                    )
                  case 2:
                    reqTicket = { _id: $scope.ticket._id, status: 3 }
                    return (
                      ($scope.ticket.status = 3),
                      Tickets.update(reqTicket).then(
                        function (response) {
                          ionic.trigger('$trudesk.refreshTickets', {}), $scope.popover.hide(), $ionicHistory.goBack()
                        },
                        function (response) {
                          console.log(response)
                        }
                      ),
                      !0
                    )
                  default:
                    return !0
                }
              }
            })
        }),
        ($scope.setAssigneeChanged = function () {
          $scope.selectedAssignee = this.selectedAssignee
        }),
        ($scope.showAddComment = function ($event) {
          Users.getLoggedInUser()
            .then(function (user) {
              $scope.loggedInUser = user
            })
            .then(function () {
              $scope.popover.hide(), $scope.addCommentModal.show()
            })
        }),
        ($scope.closeAddComment = function () {
          ;($scope.commentModalForm.comment = ''), $scope.addCommentModal.hide()
        }),
        ($scope.showAddNote = function ($event) {
          Users.getLoggedInUser()
            .then(function (user) {
              $scope.loggedInUser = user
            })
            .then(function () {
              $scope.addNoteModal.show(), $scope.popover.hide()
            })
        }),
        ($scope.closeAddNote = function () {
          ;($scope.noteModalForm.note = ''), $scope.addNoteModal.hide()
        }),
        ($scope.openSetAssigneeModal = function () {
          $scope.setAssigneeModal.show(), $scope.popover.hide()
        }),
        ($scope.closeSetAssigneeModal = function () {
          void 0 !== $scope.setAssigneeModal && $scope.setAssigneeModal.hide()
        }),
        ($scope.showTicketDetails = function () {
          $scope.ticketDetailModal.show(), $scope.popover.hide()
        }),
        ($scope.closeTicketDetailsModal = function () {
          $scope.ticketDetailModal.hide()
        }),
        ($scope.closeTicket = function () {
          ;($scope.ticket.status = 3),
            Tickets.update($scope.ticket).then(
              function (response) {
                ionic.trigger('$trudesk.refreshTickets', {}), $scope.popover.hide(), $ionicHistory.goBack()
              },
              function (response) {
                console.log(response)
              }
            )
        }),
        ($scope.addCommentFormSubmit = function () {
          var comment = { ownerId: $scope.loggedInUser._id, comment: this.commentModalForm.comment }
          Tickets.addComment($scope.ticket, comment)
            .then(
              function (response) {},
              function (err) {
                console.log(err), $scope.showSnackbar(err, !0)
              }
            )
            .then(function () {
              Tickets.get($stateParams.ticketuid)
                .then(function (response) {
                  ;($scope.ticket = response.data.ticket),
                    $scope.hasNotes
                      ? ($scope.ticket.commentsMerged = _.sortBy(
                          _.union($scope.ticket.comments, $scope.ticket.notes),
                          'date'
                        ))
                      : ($scope.ticket.commentsMerged = $scope.ticket.comments),
                    void 0 === $scope.ticket.owner.image && ($scope.ticket.owner.image = 'defaultProfile.jpg')
                })
                .then(function () {
                  ;($scope.commentModalForm.comment = ''), $scope.closeAddComment()
                })
            })
        }),
        ($scope.addNoteFormSubmit = function () {
          var note = { ownerId: $scope.loggedInUser._id, note: this.noteModalForm.note }
          Tickets.addNote($scope.ticket, note)
            .then(
              function (response) {},
              function (err) {
                console.log(err), $scope.showSnackbar(err, !0)
              }
            )
            .then(function () {
              Tickets.get($stateParams.ticketuid)
                .then(function (response) {
                  ;($scope.ticket = response.data.ticket),
                    $scope.hasNotes
                      ? ($scope.ticket.commentsMerged = _.sortBy(
                          _.union($scope.ticket.comments, $scope.ticket.notes),
                          'date'
                        ))
                      : ($scope.ticket.commentsMerged = $scope.tickets.comments),
                    void 0 === $scope.ticket.owner.image && ($scope.ticket.owner.image = 'defaultProfile.jpg')
                })
                .then(function () {
                  ;($scope.noteModalForm.note = ''), $scope.closeAddNote()
                })
            })
        }),
        ($scope.setAssigneeFormSubmit = function () {
          $scope.ticket
            ? $scope.ticket.assignee && $scope.ticket.assignee._id === $scope.selectedAssignee
              ? $scope.setAssigneeModal.hide()
              : (($scope.ticket.assignee = $scope.selectedAssignee),
                Tickets.update($scope.ticket).then(
                  function (response) {
                    ;($scope.ticket = response.data.ticket),
                      ($scope.hasAssignee = 'hide'),
                      void 0 !== $scope.ticket.assignee && ($scope.hasAssignee = 'show'),
                      void 0 !== $scope.ticket.assignee &&
                        void 0 === $scope.ticket.assignee.image &&
                        ($scope.ticket.assignee.image = 'defaultProfile.jpg'),
                      $scope.hasNotes
                        ? ($scope.ticket.commentsMerged = _.sortBy(
                            _.union($scope.ticket.comments, $scope.ticket.notes),
                            'date'
                          ))
                        : ($scope.ticket.commentsMerged = $scope.ticket.comments),
                      $scope.setAssigneeModal.hide()
                  },
                  function (response) {
                    console.log(response.data), $scope.showSnackbar('Error: ' + response.data, !0)
                  }
                ))
            : $scope.showSnackbar('Invalid Ticket Object', !0)
        }),
        $scope.$on('$ionicView.beforeEnter', function () {
          ensureLogin($localStorage, $state)
        }),
        $scope.$on('$destroy', function () {
          $scope.popover.remove(),
            $scope.addCommentModal.remove(),
            $scope.addNoteModal.remove(),
            $scope.ticketDetailModal.remove(),
            $scope.setAssigneeModal.remove()
        })
    }),
  angular
    .module('trudesk.controllers.tickets', [])
    .controller('TicketsCtrl', function (
      $scope,
      $state,
      $timeout,
      $stateParams,
      $localStorage,
      $ionicListDelegate,
      $ionicNavBarDelegate,
      $ionicModal,
      $ionicPopup,
      $ionicActionSheet,
      $ionicLoading,
      $q,
      Tickets,
      Users,
      Groups,
      TicketTypes,
      Roles
    ) {
      $ionicNavBarDelegate.showBackButton(!0),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-newticket.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.newTicketModal = modal
          }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-ticket-filter.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.filterTicketModal = modal
          }),
        $ionicModal
          .fromTemplateUrl('templates/modals/modal-addComment.html', { scope: $scope, animation: 'slide-in-up' })
          .then(function (modal) {
            $scope.addCommentModal = modal
          }),
        ($scope.showLoadingTickets = !0),
        ($scope.search = { term: '' }),
        ($scope.filter = {}),
        ($scope.filter.showClosedTickets = $localStorage.showClosedTickets),
        ($scope.filter.showOnlyAssigned = $localStorage.showOnlyAssigned),
        ($scope.commentModalForm = { comment: '', ticket: '' }),
        ($scope.hasNotes = Roles.canUser('tickets:notes')),
        ($scope.isAgent = Roles.canUser('agent:*') || Roles.canUser('admin:*')),
        Roles.flushRoles().then(function () {
          $timeout(function () {
            ;($scope.hasNotes = Roles.canUser('tickets:notes')),
              ($scope.isAgent = Roles.canUser('agent:*') || Roles.canUser('admin:*'))
          }, 1)
        }),
        ($scope.showSnackbar = function (text, error) {
          _.isUndefined(error) && (error = !1)
          var textColor = '#FFFFFF'
          error && (textColor = '#ef473a'),
            Snackbar.show({
              text: text,
              showAction: !0,
              actionText: 'X',
              actionTextColor: '#ccc',
              duration: 3e3,
              textColor: textColor
            })
        }),
        ($scope.showActionSheet = function ($event, $ticket) {
          $ionicListDelegate.closeOptionButtons()
          var buttons = [{ text: 'Add Comment' }]
          $scope.isAgent &&
            (buttons.push({ text: 'Open' }), buttons.push({ text: 'Pending' }), buttons.push({ text: 'Closed' }))
          $ionicActionSheet.show({
            buttons: buttons,
            titleText: 'Ticket Options',
            cancelText: 'Cancel',
            cancel: function () {},
            buttonClicked: function (index) {
              switch (index) {
                case 0:
                  var t = _.find($scope.tickets, function (obj) {
                    return obj._id == $ticket._id
                  })
                  return ($scope.commentModalForm.ticket = t), $scope.addCommentModal.show(), !0
                case 1:
                  var reqTicket = {
                    _id: (t = _.find($scope.tickets, function (obj) {
                      return obj._id == $ticket._id
                    }))._id,
                    status: 1
                  }
                  return (
                    Tickets.update(reqTicket).then(
                      function (response) {
                        ;(t.status = 1), $scope.showSnackbar('Ticket status set to Open')
                      },
                      function (response) {
                        console.log(response)
                      }
                    ),
                    !0
                  )
                case 2:
                  reqTicket = {
                    _id: (t = _.find($scope.tickets, function (obj) {
                      return obj._id == $ticket._id
                    }))._id,
                    status: 2
                  }
                  return (
                    Tickets.update(reqTicket).then(
                      function (response) {
                        ;(t.status = 2), $scope.showSnackbar('Ticket status set to Pending')
                      },
                      function (response) {
                        console.log(response)
                      }
                    ),
                    !0
                  )
                case 3:
                  reqTicket = {
                    _id: (t = _.find($scope.tickets, function (obj) {
                      return obj._id == $ticket._id
                    }))._id,
                    status: 3
                  }
                  return (
                    Tickets.update(reqTicket)
                      .then(
                        function (response) {
                          var idx = $scope.tickets.indexOf(t)
                          ;-1 != idx && $scope.tickets.splice(idx, 1),
                            $scope.showSnackbar('Ticket status set to Closed')
                        },
                        function (response) {
                          console.log(response)
                        }
                      )
                      .finally(function () {
                        _.size($scope.tickets) < 1 ? ($scope.showNoTickets = !0) : ($scope.showNoTickets = !1)
                      }),
                    !0
                  )
                default:
                  return !0
              }
            }
          })
        }),
        ($scope.doRefresh = function () {
          ;($scope.search.term = ''),
            ($scope.shouldRefresh = !0),
            $scope.fetchTickets().finally(function () {
              $scope.$broadcast('scroll.refreshComplete')
            })
        }),
        ($scope.getUserImage = function (imageFile) {
          var url = 'http://' + $localStorage.server + '/uploads/users/' + imageFile
          return Users.getImage(url).then(function (image) {
            console.log(image)
          })
        }),
        ($scope.fetchTickets = function () {
          return (
            angular
              .element(document)
              .find('ion-item')
              .removeClass('item-remove-animate'),
            null == $scope.page && ($scope.page = 0),
            $scope.shouldRefresh && (($scope.page = 0), ($scope.hasMoreTickets = !0), ($scope.shouldRefresh = !1)),
            Tickets.all($scope.page)
              .then(
                function (response) {
                  if (_.size(response.data) < 1) $scope.hasMoreTickets = !1
                  else if (0 == $scope.page) $scope.tickets = response.data
                  else {
                    var a = $scope.tickets
                    0 < _.size(a) &&
                      ($scope.tickets = _.uniq(_.union(a, response.data), !1, function (i, k, a) {
                        return i._id
                      }))
                  }
                },
                function (error) {
                  return (
                    $scope.$broadcast('scroll.infiniteScrollComplete'),
                    ($scope.hasMoreTickets = !1),
                    -1 === error.status
                      ? $scope.showAlert('Error', 'Connection Refused.')
                      : 401 === error.status
                      ? (ionic.trigger('$trudesk.clearLoginForm', {}),
                        ($localStorage.server = void 0),
                        ($localStorage.accessToken = void 0),
                        $state.go('login'),
                        $scope.showAlert('Error', 'You have been logged out.'))
                      : void $scope.showAlert('Error', 'Error Status: ' + error.status)
                  )
                }
              )
              .finally(function () {
                ;($scope.showLoadingTickets = !1),
                  0 < _.size($scope.tickets) ? ($scope.showNoTickets = !1) : ($scope.showNoTickets = !0),
                  $scope.page++,
                  $scope.$broadcast('scroll.infiniteScrollComplete')
              })
          )
        }),
        ($scope.canFetchMoreTickets = function () {
          return void 0 === $scope.hasMoreTickets && ($scope.hasMoreTickets = !0), $scope.hasMoreTickets
        }),
        ($scope.selected = { group: '', ticketType: '', priority: '' }),
        $scope.$watch(
          'selected.ticketType',
          function (newValue, oldValue, scope) {
            newValue && newValue.priorities && ($scope.selected.priority = newValue.priorities[0])
          },
          !0
        ),
        ($scope.openNewTicket = function () {
          var groups = Groups.all(),
            types = TicketTypes.all()
          $q.all([groups, types])
            .then(
              function (results) {
                ;($scope.groups = results[0].data.groups),
                  ($scope.ticketTypes = results[1].data),
                  $scope.ticketTypes[0] &&
                    $scope.ticketTypes[0]._id &&
                    ($scope.selected.ticketType = $scope.ticketTypes[0]),
                  ($scope.modalNewTicketForm = { subject: '', issue: '' }),
                  ($scope.selected.group = '')
              },
              function (error) {
                console.error('Error - ' + error)
              }
            )
            .then(function () {
              $scope.newTicketModal.show()
            })
        }),
        ($scope.closeNewTicket = function () {
          $scope.newTicketModal.hide()
        }),
        ($scope.openFilterTicket = function () {
          $scope.filterTicketModal.show()
        }),
        ($scope.applyTicketFilter = function () {
          $scope.closeTicketFilter()
        }),
        ($scope.closeTicketFilter = function () {
          if ('' !== $scope.search.term)
            return (
              ($scope.tickets = []),
              $scope.filterTicketModal.hide(),
              Snackbar.show({ text: 'Loading...', showAction: !1, duration: 2147483647, textColor: '#FFFFFF' }),
              Tickets.search($scope.search.term).then(
                function (response) {
                  ;($scope.tickets = response.data.tickets),
                    $timeout(function () {
                      _.size($scope.tickets) < 1 ? ($scope.showNoTickets = !0) : ($scope.showNoTickets = !1)
                    }, 0),
                    ($scope.hasMoreTickets = !1),
                    Snackbar.close()
                },
                function (response) {
                  console.log(response)
                }
              )
            )
          $scope.filterTicketModal.hide(), $scope.shouldRefresh && $scope.fetchTickets()
        }),
        ($scope.clearTicketFilter = function () {
          ;($scope.search.term = ''),
            ($scope.tickets = null),
            ($scope.filter.showClosedTickets = !1),
            ($scope.filter.showOnlyAssigned = !1),
            ($localStorage.showClosedTickets = !1),
            ($localStorage.showOnlyAssigned = !1),
            ionic.trigger('$trudesk.refreshTickets', {}),
            $scope.filterTicketModal.hide()
        }),
        ($scope.searchTermChanged = function () {
          $scope.shouldRefresh = !0
        }),
        ($scope.showClosedTicketsChanged = function () {
          ;($scope.filter.showClosedTickets = this.filter.showClosedTickets),
            ($localStorage.showClosedTickets = $scope.filter.showClosedTickets),
            ($scope.shouldRefresh = !0)
        }),
        ($scope.showOnlyAssigneedChanged = function () {
          ;($scope.filtershowOnlyAssigneed = this.filter.showOnlyAssigned),
            ($localStorage.showOnlyAssigned = $scope.filter.showOnlyAssigned),
            ($scope.shouldRefresh = !0)
        }),
        ($scope.closeAddComment = function () {
          $scope.addCommentModal.hide()
        }),
        ($scope.modalNewTicketForm = { subject: '', issue: '' }),
        ($scope.addCommentFormSubmit = function () {
          var comment = { ownerId: $scope.loggedInUser._id, comment: this.commentModalForm.comment }
          Tickets.addComment($scope.commentModalForm.ticket, comment)
            .then(
              function (response) {},
              function (err) {
                console.log(err), $scope.showSnackbar(err, !0)
              }
            )
            .then(function () {
              ;($scope.commentModalForm.comment = ''), ($scope.commentModalForm.ticket = ''), $scope.closeAddComment()
            })
        }),
        ($scope.submitNewTicket = function ($event) {
          $event.preventDefault()
          var ticket = {
            type: $scope.selected.ticketType,
            subject: this.modalNewTicketForm.subject,
            issue: this.modalNewTicketForm.issue,
            group: $scope.selected.group,
            priority: $scope.selected.priority
          }
          ticket.type &&
            ticket.subject &&
            ticket.issue &&
            ticket.group &&
            ticket.priority &&
            Tickets.create(ticket)
              .then(
                function (response) {
                  ionic.trigger('$trudesk.refreshTickets', {}),
                    ($scope.modalNewTicketForm = { subject: '', issue: '' }),
                    $scope.closeNewTicket()
                },
                function (response) {
                  console.log('Error----'),
                    console.log(response),
                    $scope.showAlert('Error: ' + response.statusText, response.data.error.message)
                }
              )
              .then(function () {})
        }),
        ($scope.showAlert = function (title, text, button) {
          return (
            void 0 === button && (button = 'button-assertive'),
            $ionicPopup.alert({ title: title, template: text, okType: button })
          )
        }),
        ionic.on('$trudesk.refreshTickets', function () {
          $scope.doRefresh()
        }),
        $scope.$on('$ionicView.beforeEnter', function () {
          ensureLogin($localStorage, $state),
            ($scope.server = $localStorage.server),
            Users.getLoggedInUser().then(
              function (user) {
                $scope.loggedInUser = user
              },
              function (err) {
                console.log(err)
              }
            )
        }),
        $scope.$on('$ionicView.enter', function () {
          _.size($scope.tickets) < 1 && $scope.doRefresh()
        }),
        $scope.$on('$destroy', function () {
          $scope.newTicketModal.remove(), $scope.filterTicketModal.remove(), $scope.addCommentModal.remove()
        })
    })
